\chapter[Dise\~no]{
  \label{chp:diseno}
  DISE\~NO
}
\thispagestyle{numberingStyle}
\pagestyle{numberingStyle}


\section{Arquitectura del sistema}
La arquitectura empleada en nuestro sistema será una arquitectura en capas, una de las técnicas de diseño más usadas en las ciencias de la computación. La arquitectura basada en capas es una especialización de la arquitectura cliente-servidor donde la carga de trabajo se divide en diferentes capas con un reparto claro de las funciones.

En esta arquitectura, una capa inferior proporciona un servicio a otra copa superior. El servicio ofrecido se define mediante un contrato de servicio. De esta forma, se consigue independizar el software de ambas capas y los cambios de implementación en una de ellas, no tienen repercusión sobre las demás.

Partiendo de que la aplicación será accesible desde dispositivo móvil y navegador web, se presentará una solución al diseño basada en dos alternativas de la arquitectura basada en capas: la arquitectura en 3 capas y la arquitectura en 4 capas.


\subsection{Arquitectura en 3 capas}
En este sistema de arquitectura, se diferencian tres capas, donde `capa' significa conjunto de máquinas que cumplen una función diferente.
\\
\\ 

\begin{figure}[!h]

\includegraphics[
   keepaspectratio=true
]{./05_Diseno/arq3capas.png}
\caption{Diagrama arquitectura en tres capas}
\end{figure}

\begin{itemize} [label={}]
	\item \textbf{Capa Servidor de Datos: } Es la capa encargada de gestionar el almacenamiento de los datos.
	\item \textbf{Capa Servidor Aplicación:} Formada por la capa de  servicios y el modelo. La capa de servicios, sirve de enlace entre la interfaz de usuario y el modelo mientras que el modelo, comúnmente, se subdivide en dos: la subcapa de acceso a datos y la subcapa de lógica de negocio.
	En la primera de ellas, se lleva acabo todas las acciones relacionadas con el acceso a los datos y es la que mantiene la comunicación con el servidor de datos.
	Por su parte, la subcapa de lógica de negocio, se encarga de llevar a cabo la implementación de las funcionalidades de la aplicación.
	\item \textbf{Capa Interfaz de Usuario: } Corresponde con la interfaz gráfica que se instala en las máquinas clientes y dispositivos finales. 
\end{itemize}



\subsection{Arquitectura en 4 capas}
En esta alternativa, se añade una capa intermedia entre el cliente y el modelo que actúe de servidor de aplicaciones y que proporciones la interfaz web para clientes que accedan desde navegador web.

\begin{figure}[!h]

\includegraphics[
   keepaspectratio=true
]{./05_Diseno/arq4capas.png}
\caption{Diagrama arquitectura en cuatro capas}
\end{figure}

Un navegador, para acceder a la aplicación, necesitará de un servidor de aplicaciones que le proporcione la interfaz web. Incorporar esta interfaz dentro del servidor de aplicaciones visto en la arquitectura anterior haría que este y el modelo estén fuertemente acoplados, impidiendo que puedan ser construidos con tecnologías diferentes.

Por ello, con esta arquitectura se pretende hacer ese desacople consiguiendo que múltiples aplicaciones puedan invocar al modelo, independientemente de que sean con interfaz gráfica o mediante navegador, sin necesidad de replicar el código del modelo en cada aplicación.

En consecuente, analizados los requisitos del sistema y conociendo las necesidades del mismo, se diseñará un sistema basado en una arquitectura de cuatro capas desde el punto de vista de un cliente web, y de tres capas, desde el punto del cliente móvil.


\subsection{Arquitectura completa del sistema}
A continuación, se presenta el diseño completo que se elaborará en la aplicación.

\begin{figure}[!h]

\includegraphics[
   keepaspectratio=true
]{./05_Diseno/arqsistema.png}
\caption{Diagrama arquitectura completa del sistema}
\end{figure}

Como se puede observar en el diagrama, el sistema sigue una arquitectura en cuatro capas.

Al tener la aplicación modelo desacoplada de la aplicación web, la capa de servicios debe servir de enlace entre la capa modelo y la interfaz de usuario. Ese enlace lo ofrece mediante unos servicios REST, que exponen a la capa superior, las funcionalidades implementadas en la capa modelo.

Por su parte, las aplicaciones cliente, tanto la interfaz de usuario del cliente móvil como la interfaz web del servidor de aplicaciones, siguen el patrón de arquitectura Modelo-Vista-Controlador (MVC). En ellas, el modelo no se encuentra implementado en la propia aplicación, sino que es accedido mediante un cliente REST que consume los servicios ofrecidos por la capa de servicios del modelo. De esta forma, ambas aplicaciones finales, invocan al modelo sin necesidad de tenerlo replicado.


\section{Capa Modelo}
Esta capa es la encargada de implementar la lógica de negocio de la aplicación, lo que implica el manejo de las entidades persistentes y el acceso a los datos. Como podemos observar en la Figura 6.4, y debido a la arquitectura establecida, el modelo estará compuesto por una subcapa de acceso a datos, otra de lógica de negocio y una última de servicios REST, la que permitirá acceder remotamente a las funcionalidades de la aplicación independientemente del tipo de  cliente final.

\begin{figure}[H]
\includegraphics[
   keepaspectratio=true
]{./05_Diseno/disenomodelo.png}
\caption{Diagrama diseño modelo}
\end{figure}


\subsection{Diseño módulo acceso a datos}
En la capa de acceso a datos se definirán el conjunto de entidades persistentes que manejará la aplicación y se empleará el patrón de diseño Data-Access-Object (DAO) para abstraer la persistencia de las entidades así como la fuente de datos empleada.

Por cada entidad persistente existirá un DAO encargado de gestionar la comunicación con la fuente de datos empleada.

\subsubsection*{Patrón de diseño DAO}
Este patrón de diseño intenta desacoplar el acceso a los datos de su almacenamiento subyacente. Los datos persistentes, actualmente, dependen en gran medida del tipo de base de datos utilizada: base de datos relacional, base de datos orientada a objetos, archivos planos... siendo las bases de datos relacionales las más utilizadas. 

Partiendo de que los accesos a diferentes tipos de bases de datos se realizan de manera muy diferente, utilizar este patrón en lugar de acceder directamente a la fuente de datos, nos permite pasar de un tipo de fuente de datos a otro diferente sin tener que realizar modificaciones en la lógica de negocio.


\begin{figure}[H]
\includegraphics[
   keepaspectratio=true
]{./05_Diseno/patrondao.jpg}
\caption{Diagrama diseño modelo}
\end{figure}

En la Figura 6.6 se muestra un pequeño diagrama con los elementos participantes en este patrón de diseño.

\begin{itemize}
	\item \textbf{Business Object: } Representa la clase con la lógica de negocio. Es la responsable de saber qué y cómo modificar el contenido de los datos pero no cómo almacenarlo.
	\item \textbf{Data Access Object: } Se encarga de ocultar la fuente de datos real de manera que el objeto con la lógica de negocio (Business Object) se comunica con este en vez de hacerlo directamente con el objeto de acceso a los datos.
	\item \textbf{DataSource: } Es la fuente real de datos y el que realiza la conexión con la base de datos. En la mayoría de casos, existe una base de datos relacional a la que se accede a través de SQL.
	\item \textbf{Transfer Object: } Es el objeto que se utiliza para transferir el contenido de los datos reales, del \textit{Data Access Object} al objeto de negocio \textit{Business Object}. Representa los datos almacenados en la base de datos.
\end{itemize}

\newpage
\subsubsection*{Diagrama clases persistentes}
\begin{figure}[H]
\includegraphics[
   keepaspectratio=true
]{./05_Diseno/disenoclases.png}
\caption{Diagrama diseño modelo}
\end{figure}

En el diagrama se muestran las clases persistentes que manejará la aplicación. A continuación, se detallará brevemente, el significado y funcionalidad de cada una:

\begin{itemize}
	\item \textbf{User: } Es la clase encargada de gestionar la información de los usuarios registrados en la aplicación.
	\item \textbf{Role: } Enumerado con los roles disponibles para un usuario: \textit{ADMIN, MODERATOR y USER}.
	\item \textbf{Route: } Clase encargada de guardar la información sobre las rutas creadas por los usuarios. Las rutas están compuestas por \textit{RouteDays}.
	\item \textbf{RouteDay: } Clase con una relación fuerte de composición con la clase \textit{Route}. Su tiempo de vida está condicionada por la vida de la clase que la incluye. Mantiene la información para cada uno de los días que componen la duración de una ruta.
	\item \textbf{RouteState: } Enumerado con los diferentes estados por los que pasa una ruta en el tiempo: \textit{PENDING, IN\_PROGRESS y COMPLETED}.
	\item \textbf{Stay: } Entidad con la funcionalidad de gestionar las visitas que decida hacer un usuario en un día de una ruta determinada. La visita, puede ser a lugares obtenidos de una fuente externa (\textit{Foursquare}) o a eventos gestionados por la propia aplicación.
	\item \textbf{Place: } Entidad que registra y almacena los detalles sobre los lugares extraídos de la fuente externa.
	\item \textbf{Event: } Es la clase encargada de gestionar los eventos dados de alto en el sistema. Los eventos están compuestos por \textit{EventDays}.
	\item \textbf{EventDay: } Clase con una relación fuerte de composición con la clase \textit{Event}. Su tiempo de vida está condicionada por la vida de la clase que la incluye. Mantiene la información para cada uno de los días que componen al evento.
	\item \textbf{EventPlace: } Es la clase donde se maneja toda la información sobre las distintas ubicaciones y actividades que incluye un día determinado del evento.
	\item \textbf{Category: } Clase que almacena la información relevante a las categorías sobre las que se filtran los lugares obtenidos de \textit{Foursquare}.
	\item \textbf{SubCategory: } Establece una jerarquía con la clase anterior. Almacena las categorías que son un subtipo de una categoría determinada.
\end{itemize}


\subsection{Diseño módulo lógica de negocio}
En este módulo o subcapa es donde se implementan y desarrollan los casos de uso previamente especificados.

En el diseño de los servicios ofrecidos se utilizará el patrón de diseño \textit{Fachada}. Con este patrón, se crearán una serie de \textit{Servicios} que agruparán y gestionarán un conjunto determinado de entidades y componentes ofrecidos por la capa de acceso a datos. Estos servicios ofrecerán una serie de funcionalidades abstrayendo la complejidad de implementación y de dependencia con demás componentes.

\subsubsection*{Patrón Fachada}
El propósito del patrón de diseño Fachada es proporcionar una interfaz unificada para un conjunto de interfaces en un subsistema. Se define una interfaz de nivel superior lo que permite hacer el subsistema más fácil de utilizar.

\begin{figure}[H]
\centering
\includegraphics[
   keepaspectratio=true
]{./05_Diseno/patronfacade.png}
\caption{Ejemplo patrón de diseño Fachada}
\end{figure}

Estructurar un sistema en subsistemas ayuda a reducir la complejidad. Uno de los objetivos más comunes de diseño es minimizar la comunicación y las dependencias entre los subsistemas. Esto se puede lograr haciendo uso de este patrón.

Como podemos observar en la Figura 6.7, utilizando el patrón fachada se proporciona una interfaz única de acceso que se encargar de gestionar las comunicaciones y dependencias necesarias con otros módulos o subsistemas para realizar sus funcionalidades. Permite abstraer al cliente de cómo se gestionan las comunicaciones con los diferentes módulos.


\subsubsection*{Diseño de los servicios}
\begin{figure}[H]
\centering
\includegraphics[
   keepaspectratio=true
]{./05_Diseno/disenoservicios.png}
\caption{Diagrama diseño servicios}
\end{figure}

En la Figura 6.8 podemos ver el diseño de los servicios que implementarán las funcionalidades de la aplicación. Se detallan brevemente a continuación:

\begin{itemize}
	\item \textbf{RouteService: } Servicio encargado de implementar los casos de uso o funcionalidades referentes a las rutas. Gestionan tanto las propias rutas como su composición por días y las visitas incluidas en cada día.
	\item \textbf{EventService: } Este servicio es el encargado de la gestión de los eventos en la aplicación. Al igual que con el anterior servicio, este incluye las funcionalidades para gestionar la composición por días y los lugares o ubicaciones específicas que existan dentro de un mismo evento.
	\item \textbf{UserService: } Ofrece los casos de uso referente a la entidad usuarios. Incluye desde el manejo de los datos sobre los usuarios hasta las funcionalidades de autenticación.
	\item \textbf{CategoryService: } Es el servicio encargado de administrar las categorías.
	\item \textbf{PlaceService: } Presenta las funcionalidades necesarias para gestionar los lugares que se registran en la aplicación.
	\item \textbf{ExternalService: } Es el servicio encargado de ofrecer las funciones que requieren de una comunicación con fuentes de datos externos. En este caso, este servicio, mantiene una dependencia con el API de \textit{Foursquare} y de \textit{GoogleMaps}.
\end{itemize}

\subsection{Diseño módulo servicios REST}
En el módulo de servicios REST se ofrecerán las funcionalidades de la capa de lógica de negocio a través de recursos accesibles por la red mediante peticiones \textit{http}. Estos servicios web se crearán siguiendo el estilo arquitectónico Representational State Transfer (REST) mediante el uso del API de programación \textit{JAX-RS}.

Se utilizará el patrón de diseño \textit{Data Transfer Object} (DTO).

\subsubsection*{Patrón de diseño DTO}
Es un patrón de diseño que se utiliza para transferir varios atributos entre un cliente y un servidor, o viceversa. De esta forma se consigue encapsular los objetos de negocio de manera que, cuando un cliente solicita al servidor determinada información, este construye un objeto de transferencia que rellena con los atributos del objeto de negocio y se lo envía finalmente al cliente.

Generalmente, este patrón de diseño está compuesto por las siguientes clases:

\begin{itemize}
	\item \textbf{Objeto de transferencia: } Clase POJO únicamente compuesta por atributos y métodos de lectura y escritura.
	\item \textbf{Clase de negocio: } Clase encargada de implementar las funcionalidades de la aplicación. Envía o recibe la clase \textit{Objeto de transferencia} por parte del cliente, que modifica utilizando los datos de la base de datos.
\end{itemize}


\subsubsection*{Diagrama módulo REST}
A continuación se mostrará un diagrama de ejemplo, con las clases involucradas en la gestión de los casos de uso de usuarios.

\begin{figure}[H]
\centering
\includegraphics[
   keepaspectratio=true
]{./05_Diseno/disenorest.png}
\caption{Diagrama ejemplo casos de uso usuario}
\end{figure}


\begin{itemize}
	\item \textbf{UserDto: } Es el objeto de transferencia.
	\item \textbf{User: } Objeto de negocio para la entidad usuario.
	\item \textbf{UserResource: } Interfaz que expone ciertas funcionalidades a través de un recurso web. En este ejemplo, se define la implementación \textit{UserResourceImpl}, encargada de implementar las funciones establecidas en la interfaz. Los datos e información manejada se hace a través del objeto de transferencia.
	\item \textbf{UserService: } Servicio de lógica de negocio que gestiona los casos de uso y funcionalidades referentes a usuarios. Manipula el objeto de negocio \textit{User} y sus funcionalidades son invocadas por parte de \textit{UserResouceImpl}.
	\item \textbf{UserConverter: } Clase de utilidad que permite a la implementación del recurso \textit{UserResource} transformar el objeto de negocio en un objeto de transferencia, y viceversa.

\end{itemize}

El resto de servicios definidos en la aplicación seguirán una estructura similar. Se ofrecerán recursos web accesibles mediante \textit{http} que permitirán la invocación remota de la lógica de negocio de la aplicación.


\newpage
\section{Capa Presentación}
La capa de presentación, también conocida como \textit{capa cliente} o \textit{capa usuario}, es la encargada de separar la interacción del usuario respecto a la lógica de negocio. Esta capa simplemente presenta la información al usuario y recibe las peticiones que debe comunicar a la capa de lógica de negocio.

En nuestro sistema, existen dos presentaciones de la aplicación completamente diferentes e independientes: una aplicación web accesible desde navegador web y una aplicación para dispositivos móviles.

\subsection{Aplicación web}
La aplicación web se implementará en un servidor de aplicaciones que recibirá y gestionará todas las peticiones del cliente. Este será encargado de mostrarle al cliente la interfaz web así como comunicarse con la capa modelo, accediendo mediante los servicios REST a las funcionalidades del sistema.

Seguirá el patrón de arquitectura Modelo-Vista-Controlador (MVC).

\subsubsection*{Patrón Modelo-Vista-Controlador}
MVC es un patrón de arquitectura de software que separa los datos y la lógica de negocio, de su representación. Está formado por tres componentes distintos: modelo, vista y controlador.

El modelo es la información de la aplicación y el que proviene de la lógica de negocio. La vista, por su parte, es la representación en pantalla mientras que el controlador es el encargado de mantener la comunicación con el modelo y definir la forma en que la interfaz reacciona a las peticiones del usuario. Antes del patrón MVC, los diseños de interfaz de usuario tendían a agrupas estos objetos. Con este patrón se consigue desacoplar vistas y modelos estableciendo un protocolo de `suscripción-notificación' entre ellos.

\subsubsection*{Diagrama MVC aplicación web}
A continuación se mostrará un diagrama donde se verán los componentes MVC anteriormente comentados en el sistema de nuestra aplicación web.

\begin{figure}[H]
\centering
\includegraphics[
   keepaspectratio=true
]{./05_Diseno/mvccapaweb.png}
\caption{Diagrama MVC aplicación web}
\end{figure}

El controlador recibirá las solicitudes del usuario y obtendrá los datos del modelo a través del servicio REST especificado. Con estos datos, el controlador creará la vista correspondiente, que será entregada al usuario.


\subsection{Aplicación móvil}
La aplicación móvil será desarrollada mediante el SDK Ionic. Una aplicación Ionic es, en esencia, una aplicación Angular que se base en una arquitectura Modelo-Vista-VistaModelo (MVVM).

\subsubsection*{Patrón Modelo-Vista-VistaModelo}
Este modelo se considera una adaptación del patrón anteriormente explicado, el Modelo-Vista-Controlador.

MVC y MVVM siguen un funcionamiento similar pero con unas pequeñas diferencias. En el primero de ellos, cuando la lógica de negocio realiza un cambio, es necesario que este cambio se actualice en la vista. Con el patrón MVVM, en vez de controlar los cambios manualmente en la vista o en los datos, estos se actualizan directamente cuando sucede un cambio en ellos.

\begin{figure}[H]
\centering
\includegraphics[
   keepaspectratio=true
]{./05_Diseno/mvvm.png}
\caption{Diagrama patrón MVVM}
\end{figure}


\section{Diseño físico de los datos}
\subsection{Modelo Entidad-Relación}
\subsection{Modelo Relacional}






